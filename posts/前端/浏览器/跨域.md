---
title: '跨域'
date: '2023-06-30 10:48:52'
---
  
## 跨域的出现

浏览器安全，防止网站的请求发送到不明、不安全的网站

不同的协议（http https）、主机名(aaa.com bbb.com)、端口(80 8080)，浏览器端限制的请求交互。

## 跨域的具体限制

异步请求限制

Cookie限制

响应限制（服务端需要返回cors请求头，否则浏览器端无法处理详情）

## 如何解决跨域

### JSONP

JSONP实现跨域

> 
> 
> 
> JSONP（JSON with Padding）是一种利用script标签实现跨域请求的技术。它通过动态创建`<script>`标签，将跨域请求的URL作为其src属性值，并通过回调函数的方式接收响应数据。
> 
> 下面是一个简单的示例，演示如何使用JSONP进行跨域请求：
> 
> ```
> // 定义回调函数，用于处理接收到的响应数据
> function handleResponse(data) {
>   console.log('Received data:', data);
> }
> 
> // 创建一个script标签
> const script = document.createElement('script');
> 
> // 拼接跨域请求的URL，并指定回调函数的名称
> const url = '<https://api.example.com/data?callback=handleResponse>';
> 
> // 设置script标签的src属性，发起跨域请求
> script.src = url;
> 
> // 将script标签添加到文档中，请求会立即发起
> document.body.appendChild(script);
> 
> ```
> 
> 在上述示例中，我们定义了一个名为`handleResponse`的回调函数，用于处理接收到的响应数据。通过在URL中指定`callback=handleResponse`，我们告诉服务器在响应中调用该回调函数，并将数据作为参数传递。
> 
> 然后，我们动态创建一个`<script>`标签，并设置其src属性为跨域请求的URL。这会触发浏览器发起一个GET请求到指定的URL，并将响应作为执行该回调函数的JavaScript代码执行。
> 
> 由于script标签通过src属性引入的资源是不受同源策略限制的，所以这种方式可以实现跨域请求。服务器响应的内容应该是一个函数调用，该调用会执行我们提供的回调函数，并传入数据作为参数。
> 
> 在接收到响应后，我们的回调函数会被执行，并处理传递进来的数据。
> 

### WebSocket

### 代理服务器

前端请求 → 代理服务器 →目标服务器

后端响应 → 代理服务器 → 前端

区分正向代理(Webpack DevServer)和反向代理(Nginx)

> 区别：
- 方向：正向代理代理的是客户端，位于客户端与目标服务器之间；反向代理代理的是服务器端，客户端请求直接发送给反向代理，反向代理再将请求转发到后端服务器。
- 配置：正向代理需要在客户端进行代理配置，而反向代理由服务器端进行配置。
- 使用场景：正向代理常用于保护客户端的身份和访问限制，反向代理常用于负载均衡和服务端的性能优化。
> 

> 
> 
> 
> 前端的Nginx `proxy_pass`操作属于反向代理。
> 
> 当前端的Nginx服务器通过`proxy_pass`将请求转发给后端服务时，它充当的是反向代理角色。客户端向Nginx发起请求，Nginx会将请求转发给后端的目标服务器，并将响应传递回客户端。
> 
> 具体而言，Nginx的`proxy_pass`配置用于指定后端目标服务器的地址，并将客户端请求转发到该地址。这种配置常见于负载均衡、缓存加速、HTTPS加密等场景，其中Nginx充当反向代理服务器，将请求转发给后端的真实服务器进行处理，然后将响应返回给客户端。
> 
> 因此，前端的Nginx `proxy_pass`转发请求给后端服务属于反向代理，与正向代理不同，它是从服务器端进行配置和管理的，无需在客户端进行代理配置。
> 

> 
> 
> 
> Webpack的`devServer`属于正向代理。
> 
> `devServer`是Webpack提供的一个开发服务器，用于在开发环境中运行应用程序。其中的代理功能允许开发者在开发过程中，将某些请求转发到其他服务器上。
> 
> 通过配置`devServer`的`proxy`属性，可以指定代理规则，将特定请求转发到指定的目标服务器。当开发者在浏览器中发起请求时，`devServer`会代理请求转发到目标服务器，接收响应后再返回给浏览器。
> 
> 虽然Nginx也可以用作反向代理，但是`devServer`不同于Nginx，它是一个在开发环境中使用的工具。它通常用于开发调试和代码热更新，并提供了一些方便的功能，如自动重新加载和热模块替换。
> 
> 因此，Webpack的`devServer`属于正向代理，它代理的是发起请求的客户端（浏览器），将请求转发到目标服务器。这使得开发者可以在开发环境中避免跨域问题，请求可以直接发送给目标服务器进行处理，从而进行更舒适的开发体验。
> 

### CORS请求头

> 
> 
> 
> 使用CORS（Cross-Origin Resource Sharing）请求头可以解决前端跨域问题。CORS允许浏览器在跨域请求中携带额外的信息，并允许服务器决定是否接受该请求。
> 
> 以下是使用CORS请求头解决前端跨域问题的步骤：
> 
> 1. 服务器端配置：在服务器端的响应头中添加CORS相关的头信息。最常用的字段是`Access-Control-Allow-Origin`，用于指定允许访问的域名或通配符``表示允许任意域名访问。
>     
>     例如，在服务器端的响应中添加以下头信息：
>     
>     ```
>     Access-Control-Allow-Origin: <https://www.example.com>
>     
>     ```
>     
> 2. 浏览器端请求：在浏览器端发送跨域请求时，会自动添加一些预检请求（preflight）以获取服务器的CORS配置。预检请求使用HTTP OPTIONS方法，并带有与实际请求相同的URL和一些特定的请求头。
> 3. 服务器端响应预检请求（可选）：如果浏览器发送了预检请求，服务器需要对该请求进行响应。服务器可以通过添加相应的CORS头信息来对预检请求做出回应，如`Access-Control-Allow-Methods`（允许的HTTP方法）和`Access-Control-Allow-Headers`（允许的自定义请求头）。
>     
>     例如，在预检请求的响应中添加以下头信息：
>     
>     ```
>     Access-Control-Allow-Methods: GET, POST
>     Access-Control-Allow-Headers: Content-Type
>     
>     ```
>     
> 4. 浏览器端处理响应：浏览器接收到预检请求的响应后，根据服务器的CORS配置判断是否允许发送实际的跨域请求。
> 
> 使用CORS请求头，可以灵活地配置哪些域名被允许跨域访问，并且可以细粒度地控制允许的HTTP方法和自定义头。这种方式不需要修改前端代码，而是通过服务器端的配置来解决跨域问题。
>